/*
 * This file is part of the GeOxygene project source files. 
 * 
 * GeOxygene aims at providing an open framework which implements OGC/ISO specifications for 
 * the development and deployment of geographic (GIS) applications. It is a open source 
 * contribution of the COGIT laboratory at the Institut G�ographique National (the French 
 * National Mapping Agency).
 * 
 * See: http://oxygene-project.sourceforge.net 
 *  
 * Copyright (C) 2005 Institut G�ographique National
 *
 * This library is free software; you can redistribute it and/or modify it under the terms
 * of the GNU Lesser General Public License as published by the Free Software Foundation; 
 * either version 2.1 of the License, or any later version.
 *
 * This library is distributed in the hope that it will be useful, but WITHOUT ANY 
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A 
 * PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License along with 
 * this library (see file LICENSE if present); if not, write to the Free Software 
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 *  
 */

options {
    STATIC=false;
}

PARSER_BEGIN(WktGeOxygene)

package fr.ign.cogit.geoxygene.util.conversion;

import java.util.StringTokenizer;
import java.util.List;
import java.util.ArrayList;
import java.util.Iterator;

import java.io.InputStream;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.File;
import java.io.OutputStream;
import java.io.PrintStream;
import java.io.IOException;
import java.io.FileNotFoundException;
import java.io.ByteArrayInputStream;

import fr.ign.cogit.geoxygene.spatial.coordgeom.DirectPosition;
import fr.ign.cogit.geoxygene.spatial.coordgeom.GM_LineString;
import fr.ign.cogit.geoxygene.spatial.coordgeom.GM_Polygon;
import fr.ign.cogit.geoxygene.spatial.geomprim.GM_Ring;
import fr.ign.cogit.geoxygene.spatial.geomaggr.GM_MultiPoint;
import fr.ign.cogit.geoxygene.spatial.geomaggr.GM_MultiCurve;
import fr.ign.cogit.geoxygene.spatial.geomaggr.GM_MultiSurface;
import fr.ign.cogit.geoxygene.spatial.geomroot.GM_Object;
import fr.ign.cogit.geoxygene.spatial.geomaggr.GM_Aggregate;
import fr.ign.cogit.geoxygene.spatial.geomprim.GM_Point;

@SuppressWarnings("unchecked")
public class WktGeOxygene
{
    static class EndOfFile extends Exception {private static final long serialVersionUID = 1L;}
    static class EmptyLine extends Exception {private static final long serialVersionUID = 1L;}
    
    /*-----------------------------------------------------*/
    /*- Create Wkt object(s) from GM_Object ---------------*/
    /*-----------------------------------------------------*/

    /*- GM_Aggregate --------------------------------------*/

    static String geometryCollectionTaggedText(GM_Aggregate aggregate) 
    {
        StringBuffer result=new StringBuffer();
        result.append("GEOMETRYCOLLECTION ");
        if (IsEmptyUtil.isEmpty(aggregate)) result.append("EMPTY");
        else {
	        result.append("(");
	        for (int i=0; i<aggregate.size(); i++) {
	            if (i!=0)
	                result.append(", ");
	            result.append(makeWkt(aggregate.get(i)));
	        }
	        result.append(")");
        }
        return result.toString();
    }

    /*- GM_MultiPoint -------------------------------------*/

    static String multiPointTaggedText(GM_MultiPoint multiPoint) 
    {
        GM_Point point;
        StringBuffer result=new StringBuffer();
        result.append("MULTIPOINT ");
        if (IsEmptyUtil.isEmpty(multiPoint)) result.append("EMPTY");
        else {
	        result.append("(");
	        for (int i=0; i<multiPoint.size(); i++) {
	            point=multiPoint.get(i);
	            if (i!=0)
	                result.append(", ");
	            result.append(point(point));
	        }
	        result.append(")");
        }
        return result.toString();
    }

    /*- GM_MultiCurve -------------------------------------*/

    static String multiLineStringTaggedText(GM_MultiCurve multiCurve) 
    {
        GM_LineString lineString;
        StringBuffer result=new StringBuffer();
        result.append("MULTILINESTRING ");
        if (IsEmptyUtil.isEmpty(multiCurve)) result.append("EMPTY");
        else {
	        result.append("(");
	        for (int i=0; i<multiCurve.size(); i++) {
	            lineString=(GM_LineString)multiCurve.get(i);
	            if (i!=0)
	                result.append(", ");
	            result.append(lineStringText(lineString));
	        }
	        result.append(")");
        }
        return result.toString();
    }

    /*- GM_MultiSurface -----------------------------------*/

	static String multiPolygon(GM_MultiSurface multiSurface)
	{
        StringBuffer result=new StringBuffer();
        for (int i=0; i<multiSurface.size(); i++) {
  			GM_Object surface;
            surface=multiSurface.get(i);
            if (i!=0)
                result.append(", ");
            if (surface instanceof GM_Polygon)
            	result.append(polygonText((GM_Polygon)surface));
        	else if (surface instanceof GM_MultiSurface)
        		result.append(multiPolygon((GM_MultiSurface)surface)); 
        }
        return result.toString();
	}

	static String multiPolygonText(GM_MultiSurface multiSurface)
	{
        StringBuffer result=new StringBuffer();
        result.append("(");
		result.append(multiPolygon(multiSurface));
        result.append(")");
		return result.toString();
	}

    static String multiPolygonTaggedText(GM_MultiSurface multiSurface) 
    {
        StringBuffer result=new StringBuffer();
        result.append("MULTIPOLYGON ");
        if (IsEmptyUtil.isEmpty(multiSurface)) result.append("EMPTY");
        else {
			result.append(multiPolygonText(multiSurface));
	    }
        return result.toString();
    }

    /*- GM_LineString -------------------------------------*/

    static String lineStringText(GM_LineString lineString)
    {
        GM_Point point;
        StringBuffer result=new StringBuffer();
        result.append("(");
        for (int i=0; i<lineString.sizeControlPoint(); i++) {
            point=new GM_Point(lineString.getControlPoint(i));
            if (i!=0)
                result.append(", ");
            result.append(point(point));
        }
        result.append(")");
        return result.toString();
    }

    static String lineStringTaggedText(GM_LineString lineString) 
    {
        StringBuffer result=new StringBuffer();
        result.append("LINESTRING ");
        if (IsEmptyUtil.isEmpty(lineString)) result.append("EMPTY");
        else result.append(lineStringText(lineString));
        
        return result.toString();
    }

    /*- GM_Polygon ----------------------------------------*/

    static String polygonText(GM_Polygon polygon)
    {
        GM_LineString lineString;

        StringBuffer result=new StringBuffer();
        result.append("("); 
        
        lineString=polygon.exteriorLineString();
        result.append(lineStringText(lineString));

        for (int i=0; i<polygon.sizeInterior(); i++) {
            lineString=polygon.interiorLineString(i);
            result.append(", ");
            result.append(lineStringText(lineString));
        }
        result.append(")");
        return result.toString();
    }

    static String polygonTaggedText(GM_Polygon polygon) 
    {
        StringBuffer result=new StringBuffer();
        result.append("POLYGON ");
        if (IsEmptyUtil.isEmpty(polygon)) result.append("EMPTY");
        else result.append(polygonText(polygon));
        return result.toString();
    }

    /*- GM_Point ------------------------------------------*/

//TODO d�terminer la dimension de la g�om�trie attendue par postgis
    static String point(GM_Point point)
    {
        DirectPosition position=point.getPosition();
        StringBuffer result=new StringBuffer();
        result.append(position.getX());
        result.append(" ");
        result.append(position.getY());
		if (!Double.isNaN(position.getZ())) {
			result.append(" ");
			result.append(position.getZ());
		}        
        return result.toString();
    }

    static String pointText(GM_Point point)
    {
        StringBuffer result=new StringBuffer();
        result.append("(");
        result.append(point(point));
        result.append(")");
        return result.toString();
    }

    static String pointTaggedText(GM_Point point) 
    {
        StringBuffer result=new StringBuffer();
        result.append("POINT ");
        if (IsEmptyUtil.isEmpty(point)) result.append("EMPTY");
        else result.append(pointText(point));
        return result.toString();
    }
    
    /*- GM_Ring -----------------------------------------*/
    
    private static String ringTaggedText(GM_Ring ring) {
		StringBuffer result=new StringBuffer();
		result.append("RING ");
		if (IsEmptyUtil.isEmpty(ring)) result.append("EMPTY");
		else result.append(ringText(ring));
		return result.toString();
	}

	private static Object ringText(GM_Ring ring) {
		GM_Point point;
		StringBuffer result=new StringBuffer();
		result.append("(");
		for (int i=0; i<ring.coord().size(); i++) {
			point=new GM_Point(ring.coord().get(i));
			if (i!=0)
				result.append(", ");
			result.append(point(point));
		}
		result.append(")");
		return result.toString();
	}

    /*- GM_Object -----------------------------------------*/

	public static String makeWkt(GM_Object object)
	{
		String result="POINT EMPTY";
		if (object instanceof GM_Point)
			result=pointTaggedText((GM_Point)object);
		else if (object instanceof GM_MultiSurface)
			result=multiPolygonTaggedText((GM_MultiSurface)object);
		else if (object instanceof GM_MultiCurve)
			result=multiLineStringTaggedText((GM_MultiCurve)object);
		else if (object instanceof GM_MultiPoint)
			result=multiPointTaggedText((GM_MultiPoint)object);
		else if (object instanceof GM_Polygon)
			result=polygonTaggedText((GM_Polygon)object);
		else if (object instanceof GM_LineString)
			result=lineStringTaggedText((GM_LineString)object);
		else if (object instanceof GM_Aggregate)
			result=geometryCollectionTaggedText((GM_Aggregate)object);
		else if (object instanceof GM_Ring)
			result=ringTaggedText((GM_Ring)object);
		return result;
	}
   
    public static String makeWkt(List<?> geomList)
    {
    	StringBuffer result=new StringBuffer();
    	Iterator<?> i=geomList.iterator();
    	while (i.hasNext()) {
    		GM_Object geom=(GM_Object)i.next();
    		String wkt=makeWkt(geom);
    		result.append(wkt);
    		result.append('\n');
    	}
    	return result.toString();
    }

    /*- Read from stream ----------------------------------*/
    
    public static GM_Object readGeOxygeneFromWkt(BufferedReader in)
    throws IOException,ParseException
    {
    	String wkt=in.readLine();
    	return makeGeOxygene(wkt);
    }
    
    public static GM_Object readGeOxygeneFromWkt(InputStream in)
    throws IOException,ParseException
    {
    	return readGeOxygeneFromWkt(new BufferedReader(new InputStreamReader(in)));
    }
    
    public static GM_Object readGeOxygeneFromWkt(String path)
    throws FileNotFoundException,IOException,ParseException
    {
    	return readGeOxygeneFromWkt(new FileInputStream(path));
    }

    /*- Write to stream -----------------------------------*/

    public static void writeWkt(String path, boolean append, GM_Object geom)
    throws IOException
    {
		writeWkt(new FileOutputStream(path, append), geom);
    }

    public static void writeWkt(String path, GM_Object geom)
    throws IOException
    {
		writeWkt(new FileOutputStream(path), geom);
    }

    public static void writeWkt(OutputStream out, GM_Object geom)
    throws IOException
    {
        new PrintStream(out).println(makeWkt(geom));
    }

    public static void writeWkt(OutputStream out, List<?> geomList)
    throws IOException
    {
        Iterator<?> i=geomList.iterator();
        while (i.hasNext()) {
            GM_Object geom=(GM_Object)i.next();
            writeWkt(out,geom);
        }
    }

    /*-----------------------------------------------------*/
    /*- Create GM_Object from Wkt object(s) ---------------*/
    /*-----------------------------------------------------*/

    public static List<?> makeGeOxygeneList(String inStrArray[])
	throws ParseException
    {
        ArrayList<GM_Object> list=new ArrayList<GM_Object>();
        for (int i=0; i<inStrArray.length; i++) {
            list.add(makeGeOxygene(inStrArray[i]));
        }
        return list;
    }
    
    static GM_Object makeGeOxygene(InputStream in)
    throws ParseException
    {
        WktGeOxygene parser=new WktGeOxygene(in);
        GM_Object geom=null;

        try {
            geom=parser.parseOneLine();
        }
        catch (EndOfFile x) {}
        catch (EmptyLine x) {}

        return geom;
    }

    public static List<?> makeGeOxygeneList(File file)
    throws Exception
    {
        return makeGeOxygeneList(new FileInputStream(file));
    }
    
    public static List<?> makeGeOxygeneList(String wkt)
    throws Exception
    {
    	InputStream in=new ByteArrayInputStream(wkt.getBytes());
    	return makeGeOxygeneList(in);
    }

    public static List<?> makeGeOxygeneList(InputStream in)
    throws ParseException
    {
        ArrayList<GM_Object> list=new ArrayList<GM_Object>();
        WktGeOxygene parser=new WktGeOxygene(in);

        while (true) {
            try {
                GM_Object geom=parser.parseOneLine();
                list.add(geom);
			} catch (EndOfFile x) {
                break;
            } catch (EmptyLine x) {}
        }
        return list;
    }

    public static GM_Object makeGeOxygene(String inStr)
    throws ParseException
    {
        InputStream in=new ByteArrayInputStream(inStr.getBytes());
        return makeGeOxygene(in);
    }
}

PARSER_END(WktGeOxygene)

TOKEN:
{
    <CONSTANT: (["-","+"])? (
         <FLOAT>
         |<FLOAT>(["e","E"] (["-","+"])?<INTEGER>)?)
    >
    |
    <#FLOAT:
            <INTEGER>
            |<INTEGER>("."<INTEGER>)?
            |"."<INTEGER>
    >
    | <INTEGER: (<DIGIT>)+>
    | <#DIGIT: ["0" - "9"]>
}

TOKEN:
{
    <POINT: <CONSTANT>((" ")+<CONSTANT>)+>
}

TOKEN:
{
    <EOL: "\n">
}

SKIP:
{
    "\t"|" "
}

DirectPosition point():
{
    DirectPosition p;
    Token xy;
}
{
    xy=<POINT>
    {
        StringTokenizer tkz=new StringTokenizer(xy.image);
        String xStr=tkz.nextToken();
        String yStr=tkz.nextToken();
        if (tkz.hasMoreTokens()) {
        	// récupération de la 3ème coordonnée si elle existe
        	String zStr=tkz.nextToken();
        	if (tkz.hasMoreTokens()) {
        		// si il y en a une 4ème, alors on est en XYZM et on prend Z
        		// sinon, on est en XYM et on ignore la mesure car elle n'est pas gérée par le type DirectPosition
        		p=new DirectPosition(Double.parseDouble(xStr), Double.parseDouble(yStr), Double.parseDouble(zStr));
				return p;
			}
        	p=new DirectPosition(Double.parseDouble(xStr), Double.parseDouble(yStr), Double.parseDouble(zStr));
            return p;
		}        
        p=new DirectPosition(
            Double.parseDouble(xStr), Double.parseDouble(yStr));
    	try {return p;} catch (Exception e) {System.out.println(e);}
    }
}

DirectPosition pointText():
{DirectPosition p=new DirectPosition();}
{
    ("(" p=point() ")" | "EMPTY")
    {try {return p;} catch (Exception e) {System.out.println(e);}}
}

GM_LineString linestringText():
{
    GM_LineString lineString=new GM_LineString();
    DirectPosition p;
}
{
    ("("
    p=point() {lineString.addControlPoint(p);}
    ("," p=point() {lineString.addControlPoint(p);})*
    ")"
    | "EMPTY")
    {try {return lineString;} catch (Exception e) {System.out.println(e);}}
}

GM_Polygon polygonText():
{
    GM_Polygon polygon=new GM_Polygon();
    GM_LineString lineString;
}
{
    ("("
    lineString=linestringText() {
   		polygon=new GM_Polygon(lineString);
   	}
    (
        ","
        lineString=linestringText() {
            polygon.addInterior(new GM_Ring(lineString));
        }
    )*
    ")"
    | "EMPTY")
    {try {return polygon;} catch (Exception e) {System.out.println(e);}}
}

GM_MultiPoint multipointText():
{
    GM_MultiPoint multiPoint=new GM_MultiPoint();
    DirectPosition p;
}
{
    ("("
    p=point() {multiPoint.add(new GM_Point(p));}
    ("," p=point() {multiPoint.add(new GM_Point(p));})*
    ")"
    | "EMPTY")
    {try {return multiPoint;} catch (Exception e) {System.out.println(e);}}
}

GM_MultiCurve multilinestringText():
{
    GM_MultiCurve multiLineString=new GM_MultiCurve();
    GM_LineString lineString;
}
{
    ("("
    lineString=linestringText() {multiLineString.add(lineString);}
    ("," lineString=linestringText()
        {multiLineString.add(lineString);})*
    ")"
    | "EMPTY")
    {try {return multiLineString;} catch (Exception e) {System.out.println(e);}}
}

GM_MultiSurface multipolygonText():
{
    GM_MultiSurface multiPolygon=new GM_MultiSurface();
    GM_Polygon polygon;
}
{
    ("("
    polygon=polygonText() {multiPolygon.add(polygon);}
    ("," polygon=polygonText() {multiPolygon.add(polygon);})*
    ")"
    | "EMPTY")
    {try {return multiPolygon;} catch (Exception e) {System.out.println(e);}}
}

GM_Aggregate geometrycollectionText():
{
    GM_Aggregate geometryCollection=new GM_Aggregate();
    GM_Object geometry;
}
{
    ("("
    geometry=geometryTaggedText() {geometryCollection.add(geometry);}
    ("," geometry=geometryTaggedText()
        {geometryCollection.add(geometry);}
    )*
    ")"
    | "EMPTY")
    {try {return geometryCollection;} catch (Exception e) {System.out.println(e);}}
}

GM_Point pointTaggedText():
{DirectPosition p;}
{
    "POINT" ("Z"|"M")?
    (p=pointText()
    {try {return new GM_Point(p);} catch (Exception e) {System.out.println(e);}}
    )
}

GM_MultiPoint multipointTaggedText():
{GM_MultiPoint mp;}
{
    "MULTIPOINT" ("Z"|"M")?
    (mp=multipointText()
    {try {return mp;} catch (Exception e) {System.out.println(e);}}
    )
}

GM_LineString linestringTaggedText():
{GM_LineString lineString;}
{
    "LINESTRING" ("Z"|"M")?
    (lineString=linestringText()
    {try {return lineString;} catch (Exception e) {System.out.println(e);}}
    )
}

GM_MultiCurve multilinestringTaggedText():
{GM_MultiCurve multiLineString;}
{
    "MULTILINESTRING" ("Z"|"M")?
    (multiLineString=multilinestringText()
    {try {return multiLineString;} catch (Exception e) {System.out.println(e);}}
    )
}

GM_Polygon polygonTaggedText():
{GM_Polygon poly;}
{
    "POLYGON" ("Z"|"M")?
    (poly=polygonText()
    {try {return poly;} catch (Exception e) {System.out.println(e);}}
    )
}

GM_MultiSurface multipolygonTaggedText():
{GM_MultiSurface mp;}
{
    "MULTIPOLYGON" ("Z"|"M")?
    (mp=multipolygonText()
    {try {return mp;} catch (Exception e) {System.out.println(e);}}
    )
}

GM_Aggregate geometrycollectionTaggedText():
{GM_Aggregate o;}
{
    "GEOMETRYCOLLECTION"
    (o=geometrycollectionText()
    {try {return o;} catch (Exception e) {System.out.println(e);}}
    )
}

int sridText():
{Token srid;}
{
	"SRID="
    srid=<CONSTANT>
    ";"
    {
        StringTokenizer tkz=new StringTokenizer(srid.image);
	    String str=tkz.nextToken();
		return Integer.parseInt(str);
	}
}

GM_Object geometryTaggedText():
{
GM_Object o;
int srid = -1;
}
{
	(srid=sridText())?
    (
    o=pointTaggedText()
    | o=linestringTaggedText()
    | o=polygonTaggedText()
    | o=multipointTaggedText()
    | o=multilinestringTaggedText()
    | o=multipolygonTaggedText()
    | o=geometrycollectionTaggedText()
    )
    {try {
    	if (srid != -1) { o.setCRS(srid); }
    	return o;
    } catch (Exception e) {System.out.println(e);}}
}

GM_Object parseOneLine() throws EmptyLine,EndOfFile:
{GM_Object o;}
{
    (o=geometryTaggedText())(<EOL>|<EOF>) {try {return o;} catch (Exception e) {System.out.println(e);}}
    | <EOL> {try {return null;} catch (Exception e) {System.out.println(e);}}
    | <EOF> {try {return null;} catch (Exception e) {System.out.println(e);}}
}
